#lang racket
(require data/heap)
(require data/order)

;;; A* from Project 1 Handout
(struct node (state pred move g h f))

(define (A* start goal? moves heuristic)
  (define (node<=? x y) (<= (node-f x) (node-f y)))
  (define Q (make-heap node<=?))
  (define ht (make-hash))
  (define (not-in-hash? SAW) (eq? #f (hash-ref ht (get-hash (car SAW)) #f)))
  (define (print-solution anode)
    (cond
      ((null? anode))
      ((null? (node-pred anode)) (list (list 'start (node-state anode) (node-g anode) (node-h anode) (node-f anode))))
      (else (append (append (print-solution (node-pred anode))) (list (list (node-move anode) (node-state anode) (node-g anode) (node-h anode) (node-f anode)))))))
  (define (add-SAW-to-heap SAW prev)
    (let* ((weight (car (cdr (cdr SAW)))) 
           (h (heuristic (car SAW))) 
           (action (car (cdr SAW)))
           (g (if (null? prev) weight (+ weight (node-g prev))))
           (f (+ g h)))
      
      (node (car SAW) prev action g h f)))
  (define (get-hash state) state)
  (define no-solution 'failure)
  
  (heap-add! Q (node start '() 'start 0 (heuristic start) (heuristic start)))
  (let loop ()
    (define curr (heap-min Q))
    (hash-set! ht (get-hash (node-state curr)) curr)
    (heap-remove-min! Q)
    (cond
      ((goal? (node-state curr)) (print-solution curr))
      (else
       (let ((SAWs (filter not-in-hash? (moves (node-state curr)))))
         (heap-add-all! Q (map (λ(x) (add-SAW-to-heap x curr)) SAWs)))
       (if (= (heap-count Q) 0) no-solution (loop))))))

;;; Helpers for Unify and Planner
(define (atom? x) (not (or (pair? x) (list? x))))
(define (first x) (if (pair? x) (car x) x))
(define (rest x) (if (pair? x) (cdr x) '()))
(define var? symbol?)
(define (not? x) (and (pair? x) (eq? (car x) '¬)))
(define (apply-subst x e)
  (cond ((var? x) (let ((p (assoc x e))) (if p (cdr p) x)))
        ((pair? x) (cons (car x) (map(λ(y) (apply-subst y e)) (cdr x))))
        (else x)))
(define (instantiate-clause c e) (map (λ(p) (apply-subst p e)) c))

;;; Unify from Project 2 Handout
(define (unify x y e)
  (define (instantiate bindings x)
    (cond
      ((eq? x '()) '())
      ((atom? x) x)
      (else (cons (instantiate bindings (first x))
                  (instantiate bindings (rest x))))))
  (define (occur? v x e)
    (or (and (symbol? x) (eq? v x))
        (and (pair? x) (ormap (λ(y) (occur? v y e)) (cdr x)))))
  (define (make-var-generator v) 
    (define n 0)
    (λ() (set! n (+ 1 n))
      (string->symbol (string-append (symbol->string v) (number->string (- n 1))))))
  (define (rename ids body fresh-id)
    (apply-subst body (map(λ(id) (cons id (fresh-id))) ids)))
  (define (rename-clause c fresh-id)
    (cdr (rename (freevarsin-clause c) (cons 'or c) fresh-id)))
  (define (freevarsin-clause c)
    (remove-duplicates (append-map freevarsin c)))
  (define (freevarsin x)
    (cond ((var? x) (list x))
          ((pair? x) (remove-duplicates (append-map freevarsin (cdr x))))
          (else '())))
  (define (extend-subst v x e)
    (cons (cons v x)
          (map (λ (p) (cons (car p) (apply-subst (cdr p) (list (cons v x))))) e)))
  (define (occur v x)
    (or (and (var? x) (eq? v x))
        (and (pair? x) (ormap (λ(y)(occur v y)) (cdr x))) ))
  
  (and e (let ((x (apply-subst x e))
               (y (apply-subst y e)))
           (cond ((equal? x y) e)
                 ((var? x) (and (not (occur x y)) (extend-subst x y e)))
                 ((var? y) (and (not (occur y x)) (extend-subst y x e)))
                 (else (and (pair? x) (pair? y) (=(length x) (length y))
                            (equal? (car x) (car y))
                            (foldl unify e (cdr x) (cdr y))))))))

;;; State, Actions, Goals
(define start-state
  '((on (a) (table)) 
    (on (b) (table))
    (on (c) (a))
    (block (a))
    (block (b))
    (block (c))
    (clear (b))
    (clear (c))
    (= (a) (a))
    (= (b) (b))
    (= (c) (c))
    (= (table) (table))))
(define actions
  '(((move b x y)
     ((on b x) (clear b) (clear y) (block b) (block y) (¬ (= b x)) (¬ (= b y)) (¬ (= x y)))
     ((on b y) (clear x) (¬ (on b x)) (¬ (clear y))))
    ((movetotable b x)
     ((on b x) (clear b) (block b) (block x) (¬ (= b x)) (¬ (= x (table))))
     ((on b (table)) (clear x) (¬ (on b x))))))
(define goal1
  '((on (a) (b)) (on (b) (c))))
(define goal2
  '((on (a) x) (on x (c))))

(define (planner start-state actions goal)
  (define (lexicographic-order state)
    (sort state datum-order))
  (define (¬? x) (and (pair? x) (eq? (car x) '¬)))
  (define (structure-action action)
    (list (car action)
          (filter (lambda (c) (not (¬? c))) (cadr action))
          (filter ¬? (cadr action))
          (filter (lambda (c) (not (¬? c))) (caddr action)) (filter ¬? (caddr action))))
  (define (get-thetas +pres state)
    (let loop ((+pres +pres) 
               (th-v '(()))) ; initially empty theta-vector
      (if (empty? +pres) th-v
          (loop (cdr +pres)
                (apply append (filter pair? (map (lambda (th)
                                                   (filter pair? (map (lambda (s-sent) (unify (car +pres) s-sent th))
                                                                      state)))
                                                 th-v)))))))
  (define (instantiate-neg-pre -pres th)
    (map cadr (instantiate-clause -pres th)))
  (define (precond-violated? -pres state)
    (ormap (lambda (c) (eq? c #t)) 
           (apply append (map (lambda (-pre)
                                (map (lambda (s-sent) (equal? -pre s-sent)) state)) -pres))))
  (define (perform-action act-lst state)
    (let ((act-name (car act-lst))
          (+pres (cadr act-lst))
          (-pres (map cadr (caddr act-lst)))
          (+post (cadddr act-lst))
          (-post (map cadr (car (cddddr act-lst)))))
      (filter pair? (map (lambda (th)
                           (if (precond-violated? (instantiate-clause -pres th) state) '()
                               (remove* (instantiate-clause -post th) 
                                        (append (instantiate-clause +post th) state))) )
                         (get-thetas +pres state)))))
  (define (move-fn state)
    (apply append (map (lambda (act) 
                         (for/list ((result (perform-action (structure-action act) state)))
                           (list (lexicographic-order result)
                                 (car act)
                                 1)))
                       actions)))
  (define (goal-fn goal state)
    (let loop ((goal-clauses goal)
               (th '()))
      (cond ((eq? th #f) #f)
            ((empty? goal-clauses) #t)
            (else (let ((unify? (ormap (lambda (s-sent) (unify (car goal-clauses) s-sent th)) state)))
                    (loop (cdr goal-clauses) unify?))))))
  (define (heuristic-fn goal state)
    (length (remove* state goal)))
  
  (let ((start (lexicographic-order start-state))
        (goal? (curry goal-fn goal))
        (heuristic (curry heuristic-fn goal)))
    (A* start goal? move-fn heuristic)))

(planner start-state actions goal1)
(planner start-state actions goal2)